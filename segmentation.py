import cv2import numpy as npimport globimport timefrom skimage import io, segmentation, colorfrom skimage.future import graphfrom tqdm import tqdmPATH_ITALIAN = 'path_italian'PATH_KMEANS = 'path_kmeans'PATH_NCUT = 'path_ncut'EXT = 'jpg'NCUT_SEG = 'NCUT_SEG'def resize(img, percentage):    # Percent of original size    width = int(img.shape[1] * percentage / 100)    height = int(img.shape[0] * percentage / 100)    dim = (width, height)    return cv2.resize(img, dim, interpolation=cv2.INTER_AREA)def nCut(img):    # Weighted KMeans in 5D    labels1 = segmentation.slic(img, compactness=10, n_segments=10)    kmeans = color.label2rgb(labels1, img, kind='avg')    g = graph.rag_mean_color(kmeans, labels1, mode='similarity')    labels2 = graph.cut_normalized(labels1,g, thresh=0.05)    ncut = color.label2rgb(labels2, kmeans, kind='avg')    return(img, ncut, kmeans)def convolve(img, alpha = 4, beta = 2):    r, c, rgb = img.shape    img_res = np.zeros((r, c))    for i in range(r):        for j in range(c):            ratio = img[i][j][2]/(img[i][j][1]+10**-6)            img_res[i][j] = 1/(1+np.e**(-alpha*(ratio-beta))) >= 0.5    return img_resdef jointRegions(img, seg_img, mask):    black = (0, 0, 0)    regions = {}    r, c, rgb = mask.shape    for i in range(r):        for j in range(c):            rgb_t = tuple(mask[i][j])            if(rgb_t != black):                if(rgb_t in regions.keys()):                    regions[rgb_t] += 1                else:                    regions.update({rgb_t: 1})    mode = max(regions, key=(lambda key: regions[key]), default=0)    res_img = np.zeros_like(img)    for i in range(r):        for j in range(c):            rgb_t = tuple(seg_img[i][j])            if(rgb_t != mode):                res_img[i][j] = list(black)            else:                res_img[i][j] = img[i][j]    return res_imgdef guassian_mask(seg_img, bin_img):    r, c, rgb = seg_img.shape    b_mask = np.multiply(seg_img[:, :, 0], bin_img)    g_mask = np.multiply(seg_img[:, :, 1], bin_img)    r_mask = np.multiply(seg_img[:, :, 2], bin_img)    res_img = np.zeros_like(seg_img)    res_img[:, :, 0] = b_mask    res_img[:, :, 1] = g_mask    res_img[:, :, 2] = r_mask    return res_imgpaths_ITA = [p.replace('//', '/').replace('\\', "/")             for p in glob.glob(PATH_ITALIAN)]percentage = 10c = 0for i in tqdm(range(len(paths_ITA))):    start = time.time()    file_name = i    img = cv2.imread(paths_ITA[i])    img_resized = resize(img, percentage)    r, c = img.shape[:2]    r_r, c_r = img_resized.shape[:2]    # Thresholding image based on R/G peaks    img_threshold = convolve(img_resized, alpha = 4, beta = 2)    original, ncut, kmeans = nCut(img_resized)    algo = ncut    mask = guassian_mask(algo, img_threshold)    conj = jointRegions(img_resized, algo, mask)    cv2.imwrite( '{}_{}NCUT.png'.format(PATH_NCUT, file_name)  , conj)    algo = kmeans    mask = guassian_mask(algo, img_threshold)    conj = jointRegions(img_resized, algo, mask)    cv2.imwrite( '{}_{}KMEANS.png'.format(PATH_KMEANS, file_name)  , conj)